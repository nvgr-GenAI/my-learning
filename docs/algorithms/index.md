# Algorithms & Data Structures 🧮

Your comprehensive guide to mastering algorithms and data structures - from fundamentals to advanced concepts. This is your one-stop resource for problem-solving, technical interviews, and competitive programming.

## 📚 Quick Access

<div class="grid cards" markdown>

- :material-book-open-variant: **Algorithm Fundamentals**

    ---

    Core concepts, complexity analysis, problem-solving patterns, and study plans

    [Learn fundamentals →](fundamentals/index.md)

- :material-strategy: **Interview Preparation**

    ---

    Study strategies, practice routines, and problem frameworks

    [Ace interviews →](interview-preparation.md)

</div>

## 🎯 Learning Path

<div class="grid cards" markdown>

- :material-code-array: **Data Structures**

    ---

    Arrays, linked lists, stacks, queues, trees, graphs, sets, hash tables

    [Explore structures →](data-structures/index.md)

- :material-sort: **Sorting Algorithms**

    ---

    Quick sort, merge sort, heap sort, and comparison-based sorting

    [Sort it out →](sorting/index.md)

- :material-graph: **Graph Algorithms**

    ---

    BFS, DFS, shortest path, MST, topological sort

    [Navigate graphs →](graphs/index.md)

- :material-chart-gantt: **Dynamic Programming**

    ---

    Optimization problems, memoization, tabulation

    [Optimize solutions →](dp/index.md)

- :material-search: **Searching Algorithms**

    ---

    Binary search, linear search, advanced search techniques

    [Find efficiently →](searching/index.md)

- :material-math-integral: **Mathematical Algorithms**

    ---

    Number theory, combinatorics, geometry

    [Crunch numbers →](math/index.md)

- :material-algorithm: **Advanced Techniques**

    ---

    Greedy, divide & conquer, backtracking, bit manipulation

    [Master techniques →](backtracking/index.md)

- :material-puzzle: **Problem-Solving Patterns**

    ---

    Two pointers, sliding window, fast & slow pointers

    [Learn patterns →](problem-solving-patterns.md)

- :material-account-tie: **Interview Preparation**

    ---

    Study plans, strategies, company-specific tips

    [Ace interviews →](interview-preparation.md)

</div>

## 📊 Algorithm Categories Overview

!!! tip "Want a deeper dive?"
    Check our [Algorithm Fundamentals](fundamentals/index.md) section for comprehensive guides on complexity analysis, study plans, and learning pathways.

### By Problem Type

| Category | Common Problems | Key Algorithms | Difficulty |
|----------|----------------|----------------|------------|
| **Array/String** | Two Sum, Sliding Window, Palindromes | Two Pointers, Hash Maps | 🟢 Easy-Medium |
| **Linked Lists** | Reverse List, Detect Cycle, Merge Lists | Fast/Slow Pointers | 🟢 Easy-Medium |
| **Trees/Binary Trees** | Traversals, Path Sum, Lowest Common Ancestor | DFS, BFS, Recursion | 🟡 Medium |
| **Binary Search Trees** | Search, Insert, Validate BST | In-order Traversal | 🟡 Medium |
| **Graphs** | Connected Components, Shortest Path | BFS, DFS, Dijkstra | 🔴 Medium-Hard |
| **Dynamic Programming** | Fibonacci, Knapsack, Edit Distance | Memoization, Tabulation | 🔴 Hard |
| **Backtracking** | N-Queens, Sudoku, Permutations | Recursive Backtracking | 🔴 Hard |
| **Greedy** | Activity Selection, Huffman Coding | Local Optimization | 🟡 Medium |

### By Data Structure

<div class="grid cards" markdown>

- :material-view-sequential: **Linear Structures**

    ---

    Arrays, Linked Lists, Stacks, Queues, Deques
    
    [Learn more →](data-structures/index.md#linear-data-structures)

- :material-graph-outline: **Hierarchical Structures**

    ---

    Binary Trees, BSTs, Heaps, Tries, Segment Trees
    
    [Learn more →](data-structures/index.md#hierarchical-data-structures)

- :material-graph: **Graph Structures**

    ---

    Adjacency Matrix/List, Weighted Graphs, Directed Graphs
    
    [Learn more →](graphs/index.md)

</div>

## 🔍 Where to Start?

We've created a dedicated **[Algorithm Fundamentals](fundamentals/index.md)** section to help you build a strong foundation. This section is organized into focused guides:

<div class="grid cards" markdown>

- :material-clock-outline: **[Time & Space Complexity](fundamentals/time-complexity.md)**

    ---

    Understanding Big O notation, algorithm efficiency, and optimization strategies

- :material-map-outline: **[Learning Pathways](fundamentals/learning-paths.md)**

    ---

    Structured learning paths based on your goals and experience level

- :material-puzzle-outline: **[Problem-Solving Patterns](fundamentals/problem-solving-patterns.md)**

    ---

    Essential algorithmic patterns with interactive examples and practice problems

- :material-target: **[Interview Strategy](fundamentals/interview-strategy.md)**

    ---

    Comprehensive approach to mastering technical interviews

- :material-calendar-outline: **[Preparation Planning](fundamentals/preparation-planning.md)**

    ---

    Customized study plans based on your timeline and goals

</div>

## 📚 Essential Learning Resources

### Online Platforms

- **[LeetCode](https://leetcode.com/)** - Interview preparation and practice
- **[HackerRank](https://www.hackerrank.com/)** - Skill assessment and challenges
- **[CodeForces](https://codeforces.com/)** - Competitive programming contests
- **[GeeksforGeeks](https://www.geeksforgeeks.org/)** - Concepts and tutorials

### Recommended Books

- **Introduction to Algorithms (CLRS)** - Comprehensive theoretical foundation
- **Cracking the Coding Interview** - Essential for tech interviews
- **Algorithm Design Manual (Skiena)** - Practical problem-solving approach
- **Elements of Programming Interviews** - Language-specific interview prep

## 🚀 Next Steps

Ready to start your algorithms journey? Choose your path:

- **New to algorithms?** Begin with [Data Structures Basics](data-structures/index.md)
- **Preparing for interviews?** Check out [Interview Strategy](fundamentals/interview-strategy.md)
- **Want to see patterns?** Explore [Problem-Solving Patterns](fundamentals/problem-solving-patterns.md)
- **Need specific algorithms?** Browse by category in the sections above

---

**Remember**: Mastering algorithms is a journey, not a destination. Stay consistent, practice regularly, and focus on understanding over memorization. You've got this! 🎯💪

!!! tip "Comprehensive Complexity Analysis"
    For a detailed explanation of time and space complexity with visual comparisons, optimization tips, and cheat sheets, check our [Time Complexity Guide](fundamentals/time-complexity.md).

## 🏆 Popular Sorting Algorithms

| Algorithm | Time Complexity | Space | Stable | In-Place | Best For |
|-----------|----------------|-------|--------|----------|----------|
| **[Quick Sort](sorting/quick-sort.md)** | O(n log n) avg | O(log n) | ❌ | ✅ | General purpose |
| **[Merge Sort](sorting/merge-sort.md)** | O(n log n) | O(n) | ✅ | ❌ | Stable sorting |
| **[Heap Sort](sorting/heap-sort.md)** | O(n log n) | O(1) | ❌ | ✅ | Guaranteed performance |
| **Insertion Sort** | O(n²) | O(1) | ✅ | ✅ | Small/nearly sorted |
| **Bubble Sort** | O(n²) | O(1) | ✅ | ✅ | Educational |

## 🎯 Essential Problem-Solving Patterns

!!! tip "Detailed Patterns Guide"
    Our [Problem-Solving Patterns](fundamentals/problem-solving-patterns.md) section covers these techniques in much greater detail with comprehensive examples, practice problems, and complexity analysis.

### Key Algorithmic Patterns

<div class="grid cards" markdown>

- :material-sync: **Two Pointers**

    ---

    Perfect for array problems, palindromes, and sum problems in O(n) time

    [Learn more →](fundamentals/problem-solving-patterns.md#two-pointers-technique)

- :material-view-carousel: **Sliding Window**

    ---

    Ideal for subarray/substring problems with O(n) efficiency

    [Learn more →](fundamentals/problem-solving-patterns.md#sliding-window-technique)

- :material-rabbit: **Fast & Slow Pointers**

    ---

    Great for cycle detection and finding middle elements

    [Learn more →](fundamentals/problem-solving-patterns.md#fast-slow-pointers-technique)

- :material-format-horizontal-merge: **Merge Intervals**

    ---

    Effective for overlapping intervals and scheduling problems

    [Learn more →](fundamentals/problem-solving-patterns.md#merge-intervals-technique)

</div>

## 📚 Learning Resources

### Essential Platforms

| Platform | Focus | Difficulty | Best For |
|----------|-------|------------|----------|
| **LeetCode** | Interview prep | Easy-Hard | FAANG interviews |
| **HackerRank** | Programming challenges | Easy-Expert | Skill assessment |
| **CodeForces** | Competitive programming | Div2-Div1 | Contest training |
| **GeeksforGeeks** | Concepts & examples | Easy-Hard | Learning fundamentals |

### Must-Read Books

- **Introduction to Algorithms (CLRS)** - Comprehensive theoretical foundation
- **Cracking the Coding Interview** - Essential for tech interviews
- **Algorithm Design Manual (Skiena)** - Practical problem-solving approach
- **Elements of Programming Interviews** - Language-specific interview prep

## 🗓️ Study Plans

!!! tip "Customized Study Plans"
    Visit our [Preparation Planning](fundamentals/preparation-planning.md) section for detailed study plans:
    
    - **12-Week Comprehensive Plan** - Complete roadmap for thorough preparation
    - **4-Week Accelerated Plan** - Focused preparation for upcoming interviews
    - **Topic-Specific Plans** - Focus areas based on your strengths and weaknesses

## 🎯 Interview Preparation Strategy

!!! tip "Comprehensive Interview Guide"
    Our [Interview Strategy](fundamentals/interview-strategy.md) section provides detailed guidance on preparation timelines, practice routines, company-specific strategies, and post-interview learning.

### Key Interview Components

<div class="grid cards" markdown>

- :material-chart-pie: **[Problem Distribution](fundamentals/interview-strategy.md#understanding-the-interview-landscape)**

    ---

    Arrays & Strings (35%), Trees & Graphs (25%), Dynamic Programming (20%), Linked Lists (15%), Others (5%)

- :material-calendar-clock: **[Preparation Timelines](fundamentals/interview-strategy.md#structured-preparation-plan)**

    ---

    12-week comprehensive plan and 4-week accelerated timeline

- :material-clock-outline: **[Daily Routines](fundamentals/interview-strategy.md#daily-practice-routine)**

    ---

    Structured practice schedules for different time constraints

- :material-map-marker-path: **[Problem Framework](fundamentals/interview-strategy.md#problem-solving-framework)**

    ---

    Step-by-step approach to solving algorithmic problems

</div>

## 🚀 Next Steps

Ready to dive deeper? Choose your path based on your current level:

<div class="grid cards" markdown>

- :material-school: **Beginner**

    ---

    Start with strong foundations:
    
    1. [Algorithm Fundamentals](fundamentals/index.md)
    2. [Data Structures Basics](data-structures/index.md)
    3. [Simple Sorting Algorithms](sorting/index.md)

- :material-certificate: **Intermediate**

    ---

    Build advanced skills:
    
    1. [Graph Algorithms](graphs/index.md)
    2. [Dynamic Programming](dp/index.md)
    3. [Problem-Solving Patterns](fundamentals/problem-solving-patterns.md)

- :material-trophy: **Advanced**

    ---

    Master complex topics:
    
    1. [Advanced Algorithms](advanced.md)
    2. [Mathematical Algorithms](math/index.md)
    3. [Interview Preparation](fundamentals/interview-strategy.md)

</div>

---

## Ready to Begin Your Algorithm Journey?

Start exploring the guides above to build your skills systematically.

Understanding algorithmic complexity is fundamental to writing efficient code.

### Big O Notation Cheat Sheet

| Complexity | Name | Example Algorithms | Performance |
|------------|------|-------------------|-------------|
| **O(1)** | Constant | Array access, Hash table lookup | 🟢 Excellent |
| **O(log n)** | Logarithmic | Binary search, Balanced BST operations | 🟢 Excellent |
| **O(n)** | Linear | Linear search, Array traversal | 🟡 Good |
| **O(n log n)** | Linearithmic | Merge sort, Heap sort, Fast Fourier Transform | 🟡 Good |
| **O(n²)** | Quadratic | Bubble sort, Selection sort, Nested loops | 🔴 Poor |
| **O(n³)** | Cubic | Floyd-Warshall, Matrix multiplication | 🔴 Very Poor |
| **O(2ⁿ)** | Exponential | Recursive Fibonacci, Subset generation | 🔴 Terrible |
| **O(n!)** | Factorial | Permutation generation, Traveling salesman (brute force) | 🔴 Terrible |

### Complexity Growth

!!! info "See Visualization"
    For interactive complexity visualizations and detailed explanations of algorithm efficiency, check our [Time Complexity Guide](fundamentals/time-complexity.md).

## 🏆 Problem-Solving Strategies

!!! tip "Detailed Problem-Solving Guide"
    Visit our comprehensive [Problem-Solving Patterns](fundamentals/problem-solving-patterns.md) guide for detailed strategies, examples, and practice problems.

<div class="grid cards" markdown>

- :material-lightbulb-on-outline: **Understanding Approach**

    ---
    
    Problem analysis, constraints identification, and selecting the right algorithmic approach
    
    [Learn more →](fundamentals/problem-solving-patterns.md#approach-selection)

- :material-pattern: **Pattern Recognition**

    ---
    
    Two Pointers, Sliding Window, Hash Maps, and other essential problem-solving patterns
    
    [Learn more →](fundamentals/problem-solving-patterns.md#common-patterns)

</div>

## 📚 Essential Topics by Category

### 🔢 **Arrays & Strings**

- Two pointers technique
- Sliding window
- Prefix sums
- Hash table applications
- String matching algorithms

### 🔗 **Linked Lists**

- Singly/doubly linked lists
- Fast and slow pointers
- Cycle detection
- Merging and sorting

### 🌳 **Trees & Binary Trees**

- Tree traversals (preorder, inorder, postorder)
- Binary search trees
- Balanced trees (AVL, Red-Black)
- Segment trees, Fenwick trees

### 📊 **Graphs**

- Graph representations
- BFS and DFS traversals
- Shortest path algorithms
- Minimum spanning trees
- Topological sorting

### 🎯 **Dynamic Programming**

- 1D and 2D DP problems
- Knapsack variations
- Longest common subsequence
- Edit distance
- Matrix chain multiplication

### ⚡ **Advanced Topics**

- Union-Find (Disjoint Set)
- Trie data structure
- Heap and priority queues
- Bit manipulation
- String algorithms (KMP, Rabin-Karp)

## 🎯 Interview Preparation Roadmap

### Phase 1: Foundations (2-3 weeks)

1. **Arrays & Strings**: Two pointers, sliding window
2. **Linked Lists**: Basic operations, cycle detection
3. **Stacks & Queues**: Implementation and applications
4. **Recursion**: Base cases, recursive thinking

### Phase 2: Core Structures (3-4 weeks)

1. **Binary Trees**: Traversals, basic operations
2. **Binary Search**: Template and variations
3. **Hash Tables**: Design and applications
4. **Sorting**: Understanding different algorithms

### Phase 3: Advanced Topics (4-5 weeks)

1. **Graphs**: BFS, DFS, shortest paths
2. **Dynamic Programming**: Classic problems
3. **Backtracking**: Systematic exploration
4. **Greedy Algorithms**: Optimization problems

### Phase 4: Mastery (2-3 weeks)

1. **System Design**: Scalability concepts
2. **Mock Interviews**: Practice under pressure
3. **Company-specific**: Research target companies
4. **Review**: Solidify weak areas

## 🔧 Practice Resources

### Online Platforms

- **[LeetCode](https://leetcode.com/)**: Comprehensive problem set
- **[HackerRank](https://www.hackerrank.com/)**: Skill-based challenges
- **[CodeForces](https://codeforces.com/)**: Competitive programming
- **[GeeksforGeeks](https://www.geeksforgeeks.org/)**: Tutorials and problems

### Books

- **"Cracking the Coding Interview"** by Gayle McDowell
- **"Elements of Programming Interviews"** by Aziz, Lee, Prakash
- **"Algorithm Design Manual"** by Steven Skiena
- **"Introduction to Algorithms"** by CLRS

### YouTube Channels

- **Abdul Bari**: Algorithm explanations
- **Back To Back SWE**: Interview-focused content
- **Tushar Roy**: Dynamic programming
- **William Fiset**: Graph algorithms

## 📈 Progress Tracking

### Problem Categories Checklist

=== "Easy (Foundation)"
    - [ ] Two Sum
    - [ ] Valid Parentheses
    - [ ] Merge Two Sorted Lists
    - [ ] Maximum Subarray
    - [ ] Best Time to Buy Stock
    - [ ] Valid Palindrome
    - [ ] Binary Tree Inorder Traversal
    - [ ] Symmetric Tree
    - [ ] Maximum Depth of Binary Tree
    - [ ] Single Number

=== "Medium (Building Skills)"
    - [ ] Add Two Numbers
    - [ ] Longest Substring Without Repeating Characters
    - [ ] Container With Most Water
    - [ ] 3Sum
    - [ ] Group Anagrams
    - [ ] Validate Binary Search Tree
    - [ ] Binary Tree Level Order Traversal
    - [ ] Construct Binary Tree from Traversals
    - [ ] Kth Largest Element in Array
    - [ ] Word Search

=== "Hard (Mastery)"
    - [ ] Median of Two Sorted Arrays
    - [ ] Regular Expression Matching
    - [ ] Merge k Sorted Lists
    - [ ] Reverse Nodes in k-Group
    - [ ] Substring with Concatenation of All Words
    - [ ] Edit Distance
    - [ ] Largest Rectangle in Histogram
    - [ ] Maximal Rectangle
    - [ ] Word Ladder II
    - [ ] Palindrome Partitioning II

!!! tip "Study Planning"
    Visit our [Preparation Planning](fundamentals/preparation-planning.md) guide for detailed weekly study templates, daily practice routines, and customizable learning plans.

## 🎓 Success Tips

### For Technical Interviews

1. **Think Out Loud**: Communicate your thought process
2. **Start Simple**: Begin with brute force, then optimize
3. **Test Your Code**: Walk through examples
4. **Handle Edge Cases**: Consider null inputs, empty arrays
5. **Ask Questions**: Clarify requirements and constraints

### For Competitive Programming

1. **Speed Matters**: Practice typing and common patterns
2. **Template Ready**: Have pre-written code snippets
3. **Read Problems Carefully**: Understand constraints
4. **Time Management**: Don't get stuck on one problem
5. **Learn from Others**: Study editorial solutions

### For Long-term Growth

1. **Consistent Practice**: Better than intensive bursts
2. **Understand, Don't Memorize**: Focus on patterns
3. **Teach Others**: Explaining helps solidify understanding
4. **Stay Updated**: Follow algorithm research and new techniques
5. **Build Projects**: Apply algorithms in real applications

---

## 🚀 Ready to Start?

Choose your learning path based on your goals and explore our detailed [Algorithm Fundamentals](fundamentals/index.md) section for comprehensive guides and strategies.

*Happy coding! 🎯*

## 🔧 Core Data Structures

<div class="grid cards" markdown>

- :material-view-sequential: **Linear Data Structures**

    ---

    Arrays, linked lists, stacks, queues with implementation details and optimizations
    
    [Explore implementations →](data-structures/linear/index.md)

- :material-tree: **Hierarchical Data Structures**

    ---

    Trees, heaps, tries, and advanced tree-based structures with practical examples
    
    [Learn tree structures →](data-structures/hierarchical/index.md)

- :material-table: **Hash-Based Structures**

    ---

    Hash tables, hash maps, and sets with collision resolution strategies
    
    [Hash structure details →](data-structures/hashing/index.md)

</div>

!!! tip "Ready to implement?"
    For complete implementations, code examples, and optimizations of these data structures, visit the [Data Structures](data-structures/index.md) section.
        self._add_node(new_node, self.head)
    
!!! tip "Linear Data Structures"
    Visit our [Linear Data Structures](data-structures/linear/index.md) section for complete implementations of:
    
    - Linked Lists (Singly & Doubly linked)
    - Stacks and their applications
    - Queues and priority queues
    - Deques for efficient operations at both ends

### Tree-Based Data Structures

!!! tip "Tree Implementations"
    See our [Tree Data Structures](data-structures/hierarchical/trees.md) guide for detailed implementations of:
    
    - Binary Search Trees (BST)
    - AVL Trees with rotation balancing
    - Red-Black Trees
    - B-Trees and B+ Trees
    - Tries for string operations
    
    All implementations include proper operations, traversal methods, and complexity analysis.
        if not node:
            return True, 0
        
        left_balanced, left_height = self._is_balanced_helper(node.left)
        right_balanced, right_height = self._is_balanced_helper(node.right)
        
        balanced = (left_balanced and right_balanced and 
                   abs(left_height - right_height) <= 1)
        height = 1 + max(left_height, right_height)
        
        return balanced, height

# Usage example
bst = BinarySearchTree()
values = [50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 45]

for val in values:
    bst.insert(val)

print(f"Inorder traversal: {bst.inorder_traversal()}")
print(f"Level order traversal: {bst.level_order_traversal()}")
print(f"Is balanced: {bst.is_balanced()}")
print(f"Search 35: {bst.search(35) is not None}")

bst.delete(30)
print(f"After deleting 30: {bst.inorder_traversal()}")
```

## 🎯 Problem-Solving Patterns & Techniques

Master these patterns to solve 80% of coding interview problems efficiently.

!!! tip "Comprehensive Pattern Guide"
    See our [Problem-Solving Patterns](fundamentals/problem-solving-patterns.md) guide for detailed explanations and implementations of all common algorithmic patterns.

### Two Pointers Technique

**Use Cases**: Array problems, string palindromes, sum problems
**Time**: O(n), **Space**: O(1)

Learn more about [Two Pointers](fundamentals/problem-solving-patterns.md#two-pointers-technique) including:

- Two Sum and its variants
- Palindrome validation
- In-place array operations
- Trapping rain water problems

### Sliding Window Pattern

**Use Cases**: Subarray problems, string problems with constraints
**Time**: O(n), **Space**: O(1) or O(k)

Learn more about [Sliding Window](fundamentals/problem-solving-patterns.md#sliding-window-technique) including:

- Maximum/minimum subarray problems
- Longest substring with constraints
- Minimum window substring
- String anagrams and permutations

### Fast & Slow Pointers (Floyd's Algorithm)

**Use Cases**: Cycle detection, finding middle element, palindrome checking
**Time**: O(n), **Space**: O(1)

```python
def has_cycle(head):
    """Detect cycle in linked list."""
    if not head or not head.next:
        return False
    
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        
        if slow == fast:
            return True
    
    return False

### Fast & Slow Pointers (Floyd's Algorithm)

**Use Cases**: Cycle detection, finding middle element, palindrome checking
**Time**: O(n), **Space**: O(1)

Learn more about [Fast & Slow Pointers](fundamentals/problem-solving-patterns.md#fast-slow-pointers-technique) including:

- Linked list cycle detection
- Finding cycle starting point
- Middle of linked list
- Happy number problem
- Palindrome linked list

### Merge Intervals Pattern

**Use Cases**: Overlapping intervals, scheduling problems
**Time**: O(n log n), **Space**: O(n)

Learn more about [Merge Intervals](fundamentals/problem-solving-patterns.md#merge-intervals-technique) including:

- Merging overlapping intervals
- Interval insertion
- Meeting room scheduling
- Interval list intersections
- Employee free time
```

## 🔍 Advanced Algorithm Categories

### Graph Algorithms Comprehensive Guide

```python
from collections import defaultdict, deque
import heapq

class Graph:
    """Comprehensive graph implementation with multiple algorithms."""
    
    def __init__(self, directed=False):
        self.graph = defaultdict(list)
        self.directed = directed
        self.weights = {}  # For weighted graphs
    
    def add_edge(self, u, v, weight=1):
        """Add edge to graph."""
        self.graph[u].append(v)
        self.weights[(u, v)] = weight
        
        if not self.directed:
            self.graph[v].append(u)
            self.weights[(v, u)] = weight
    
    def bfs(self, start):
        """Breadth-First Search traversal."""
        visited = set()
        queue = deque([start])
        result = []
        
        while queue:
            vertex = queue.popleft()
            if vertex not in visited:
                visited.add(vertex)
                result.append(vertex)
                
                for neighbor in self.graph[vertex]:
                    if neighbor not in visited:
                        queue.append(neighbor)
        
        return result
    
    def dfs(self, start):
        """Depth-First Search traversal."""
        visited = set()
        result = []
        
        def dfs_recursive(vertex):
            visited.add(vertex)
            result.append(vertex)
            
            for neighbor in self.graph[vertex]:
                if neighbor not in visited:
                    dfs_recursive(neighbor)
        
        dfs_recursive(start)
        return result
    
    def shortest_path_dijkstra(self, start, end):
        """Find shortest path using Dijkstra's algorithm."""
        distances = defaultdict(lambda: float('inf'))
        distances[start] = 0
        previous = {}
        heap = [(0, start)]
        visited = set()
        
        while heap:
            current_distance, current = heapq.heappop(heap)
            
            if current in visited:
                continue
            
            visited.add(current)
            
            if current == end:
                # Reconstruct path
                path = []
                while current in previous:
                    path.append(current)
                    current = previous[current]
                path.append(start)
                return list(reversed(path)), distances[end]
            
            for neighbor in self.graph[current]:
                distance = current_distance + self.weights.get((current, neighbor), 1)
                
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current
                    heapq.heappush(heap, (distance, neighbor))
        
        return None, float('inf')
    
    def detect_cycle(self):
        """Detect cycle in graph."""
        if not self.directed:
            return self._detect_cycle_undirected()
        else:
            return self._detect_cycle_directed()
    
    def _detect_cycle_undirected(self):
        """Detect cycle in undirected graph using DFS."""
        visited = set()
        
        def dfs(vertex, parent):
            visited.add(vertex)
            
            for neighbor in self.graph[vertex]:
                if neighbor not in visited:
                    if dfs(neighbor, vertex):
                        return True
                elif neighbor != parent:
                    return True
            
            return False
        
        for vertex in self.graph:
            if vertex not in visited:
                if dfs(vertex, -1):
                    return True
        
        return False
    
    def _detect_cycle_directed(self):
        """Detect cycle in directed graph using DFS."""
        WHITE, GRAY, BLACK = 0, 1, 2
        color = defaultdict(int)
        
        def dfs(vertex):
            if color[vertex] == GRAY:
                return True  # Back edge found
            if color[vertex] == BLACK:
                return False
            
            color[vertex] = GRAY
            
            for neighbor in self.graph[vertex]:
                if dfs(neighbor):
                    return True
            
            color[vertex] = BLACK
            return False
        
        for vertex in self.graph:
            if color[vertex] == WHITE:
                if dfs(vertex):
                    return True
        
        return False
    
    def topological_sort(self):
        """Topological sort for DAG."""
        if not self.directed:
            raise ValueError("Topological sort only applies to directed graphs")
        
        in_degree = defaultdict(int)
        
        # Calculate in-degrees
        for vertex in self.graph:
            for neighbor in self.graph[vertex]:
                in_degree[neighbor] += 1
        
        # Find vertices with no incoming edges
        queue = deque([v for v in self.graph if in_degree[v] == 0])
        result = []
        
        while queue:
            vertex = queue.popleft()
            result.append(vertex)
            
            for neighbor in self.graph[vertex]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        if len(result) != len(self.graph):
            raise ValueError("Graph contains a cycle")
        
        return result
    
    def minimum_spanning_tree_kruskal(self):
        """Find MST using Kruskal's algorithm."""
        class UnionFind:
            def __init__(self, vertices):
                self.parent = {v: v for v in vertices}
                self.rank = {v: 0 for v in vertices}
            
            def find(self, x):
                if self.parent[x] != x:
                    self.parent[x] = self.find(self.parent[x])
                return self.parent[x]
            
            def union(self, x, y):
                px, py = self.find(x), self.find(y)
                if px == py:
                    return False
                
                if self.rank[px] < self.rank[py]:
                    self.parent[px] = py
                elif self.rank[px] > self.rank[py]:
                    self.parent[py] = px
                else:
                    self.parent[py] = px
                    self.rank[px] += 1
                
                return True
        
        # Get all edges
        edges = []
        for u in self.graph:
            for v in self.graph[u]:
                weight = self.weights.get((u, v), 1)
                edges.append((weight, u, v))
        
        # Sort edges by weight
        edges.sort()
        
        # Get all vertices
        vertices = set()
        for u in self.graph:
            vertices.add(u)
            for v in self.graph[u]:
                vertices.add(v)
        
        uf = UnionFind(vertices)
        mst = []
        total_weight = 0
        
        for weight, u, v in edges:
            if uf.union(u, v):
                mst.append((u, v, weight))
                total_weight += weight
        
        return mst, total_weight

# Usage examples
graph = Graph(directed=False)
edges = [(0, 1, 4), (0, 7, 8), (1, 2, 8), (1, 7, 11), (2, 3, 7), 
         (2, 8, 2), (2, 5, 4), (3, 4, 9), (3, 5, 14), (4, 5, 10),
         (5, 6, 2), (6, 7, 1), (6, 8, 6), (7, 8, 7)]

for u, v, w in edges:
    graph.add_edge(u, v, w)

print("BFS from 0:", graph.bfs(0))
print("DFS from 0:", graph.dfs(0))
print("Shortest path 0->4:", graph.shortest_path_dijkstra(0, 4))
print("Has cycle:", graph.detect_cycle())
mst, weight = graph.minimum_spanning_tree_kruskal()
print(f"MST weight: {weight}, edges: {mst}")
```

## 📚 Learning Resources & Practice

### Essential Online Judges

| Platform | Focus | Difficulty | Best For |
|----------|-------|------------|----------|
| **LeetCode** | Interview prep, algorithms | Easy-Hard | FAANG interviews |
| **HackerRank** | Broad programming challenges | Easy-Expert | Skill assessment |
| **CodeForces** | Competitive programming | Div2-Div1 | Contest training |
| **AtCoder** | Mathematical problems | Beginner-Expert | Algorithm analysis |
| **SPOJ** | Classical problems | Varied | Foundation building |
| **Topcoder** | Algorithm competitions | Easy-Hard | Advanced techniques |
| **GeeksforGeeks** | Interview questions | Easy-Hard | Concept learning |
| **InterviewBit** | Structured learning | Easy-Hard | Systematic prep |

### Recommended Resources

!!! tip "Resource Guide"
    For a comprehensive list of books, courses, and online resources, visit our [Learning Resources](fundamentals/learning-resources.md) page.

- **Competitive Programming (Halim)** - Contest-level algorithms
- **The Art of Computer Programming (Knuth)** - Mathematical depth

### Problem Categories by Frequency

**High Frequency (Practice First):**

1. **Array & String Manipulation** (35% of interviews)
   - Two pointers, sliding window, hash tables
   - Examples: Two Sum, Longest Substring, Valid Parentheses

2. **Linked List Operations** (20% of interviews)
   - Reversal, cycle detection, merging
   - Examples: Reverse List, Merge Two Lists, Remove Nth Node

3. **Tree Traversals & Manipulation** (25% of interviews)
   - DFS, BFS, path problems, construction
   - Examples: Inorder Traversal, Max Depth, Path Sum

**Medium Frequency:**
4. **Graph Algorithms** (10% of interviews)

- BFS/DFS applications, shortest path
- Examples: Number of Islands, Course Schedule

5. **Dynamic Programming** (8% of interviews)
   - Classic problems, optimization
   - Examples: Fibonacci, Knapsack, Edit Distance

**Lower Frequency but Important:**
6. **Sorting & Searching** (2% of interviews)

- Binary search variations, custom sorting
- Examples: Search in Rotated Array, Merge Intervals

### 12-Week Study Plan

| Week | Focus | Topics | Practice Problems |
|------|-------|--------|------------------|
| **1-2** | Arrays & Strings | Two pointers, sliding window | Two Sum, Longest Substring, Valid Anagram |
| **3-4** | Linked Lists | Manipulation, cycle detection | Reverse List, Merge Lists, Detect Cycle |
| **5-6** | Stacks & Queues | LIFO/FIFO operations | Valid Parentheses, Min Stack, Queue with Stacks |
| **7-8** | Trees & BSTs | Traversals, construction | Inorder Traversal, Validate BST, Path Sum |
| **9-10** | Graphs | BFS, DFS, shortest path | Number of Islands, Course Schedule, Clone Graph |
| **11** | Dynamic Programming | Basic patterns | Climbing Stairs, House Robber, Coin Change |
| **12** | Review & Mock Interviews | Mixed problems | Random hard problems, timed practice |

### Practice Strategy

!!! tip "Daily Practice Routine"

    - **Warm-up**: 1 easy problem (10-15 min)
    - **Main**: 1-2 medium problems (30-45 min each)
    - **Challenge**: 1 hard problem (weekly)
    - **Review**: Revisit problems from 1 week ago

!!! note "Problem-Solving Framework"

    1. **Understand**: Read problem carefully, identify constraints
    2. **Plan**: Think of approach, consider edge cases
    3. **Code**: Implement solution step by step
    4. **Test**: Verify with examples, consider edge cases
    5. **Optimize**: Analyze time/space complexity, improve if possible
    6. **Reflect**: Note patterns and techniques used

### Time Complexity Goals

| Problem Type | Target Time | Complexity Analysis |
|--------------|-------------|-------------------|
| Easy Array/String | 10-15 minutes | O(n) time, O(1) space preferred |
| Medium Trees/Graphs | 20-30 minutes | O(n) or O(n log n) acceptable |
| Hard DP/Backtracking | 30-45 minutes | Focus on correctness first |

---

## Keep Building Your Skills

Consistent practice and understanding of core principles will help you master algorithms and data structures.
